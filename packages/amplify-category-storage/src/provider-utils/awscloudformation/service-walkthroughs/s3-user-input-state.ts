import { S3AccessType, S3PermissionType, S3UserInputs, GroupAccessType } from '../service-walkthrough-types/s3-user-input-types';
import { AmplifyCategories, AmplifySupportedService } from 'amplify-cli-core';
import { JSONUtilities, pathManager } from 'amplify-cli-core';
import { CLIInputSchemaValidator } from 'amplify-cli-core';
import * as fs from 'fs-extra';
import * as path from 'path';
import { AmplifyS3ResourceInputParameters } from '../cdk-stack-builder/types';

type ResourcRefType =  {
    Ref: string
}

export enum S3CFNPermissionType {
    CREATE = "s3:PutObject",
    READ = "s3:GetObject",
    DELETE = "s3:DeleteObject",
    LIST = "s3:ListBucket"
}

export interface S3CFNPermissionMapType {
  'create/update': S3CFNPermissionType[],
  read: S3CFNPermissionType[],
  delete: S3CFNPermissionType[],
}
//use this to capture input
interface IObjectS3PermissionType {
  [key: string]: S3PermissionType[];
}
export interface S3PermissionMapType extends IObjectS3PermissionType{
  'create/update': S3PermissionType[],
  read: S3PermissionType[],
  delete: S3PermissionType[],
}


export type S3CFNDependsOn = {
     category : string,
     resourceName : string,
     attributes : string[]
}

export type GroupCFNAccessType = Record<string,S3CFNPermissionType[]>;

export type S3CLIWalkthroughParams = {
    resourceName : string,
    bucketName: string,
    authPolicyName: string,
    unauthPolicyName: string,
    authRoleName: ResourcRefType,
    unauthRoleName: ResourcRefType,
    storageAccess: S3AccessType,
    selectedGuestPermissions: S3CFNPermissionType[],
    selectedAuthenticatedPermissions: S3CFNPermissionType[],
    s3PermissionsAuthenticatedPublic: string,
    s3PublicPolicy: string,
    s3PermissionsAuthenticatedUploads: string,
    s3UploadsPolicy: string,
    s3PermissionsAuthenticatedProtected: string,
    s3ProtectedPolicy: string,
    s3PermissionsAuthenticatedPrivate: string,
    s3PrivatePolicy : string,
    AuthenticatedAllowList: string,
    s3ReadPolicy: string,
    s3PermissionsGuestPublic: string,
    s3PermissionsGuestUploads: string,
    GuestAllowList: string,
    triggerFunction: string,
    service: string,
    providerPlugin: string,
    dependsOn: S3CFNDependsOn[],
    policyUUID: string,
    groupPolicyMap :  GroupCFNAccessType,
    groupList : string[] //group-names from group policy Map
}

//Data generated by amplify which should not be overridden by the user
export type S3FeatureMetadata = {
  dependsOn: S3CFNDependsOn[],
}

export type S3InputStateOptions = {
  resourceName: string;
  inputPayload?: S3UserInputs;
  metadata? : S3FeatureMetadata;
};

export class S3InputState {
  static s3InputState: S3InputState;
  _cliInputsFilePath: string; //cli-inputs.json (output) filepath
  _resourceName: string; //user friendly name provided by user
  _category: string; //category of the resource
  _service: string; //AWS service for the resource
  _inputPayload: S3UserInputs | undefined; //S3 options selected by user
  buildFilePath: string;

  constructor(resourceName : string, userInput : S3UserInputs|undefined) {
    const projectBackendDirPath = pathManager.getBackendDirPath();
    this._category = AmplifyCategories.STORAGE;
    this._service = AmplifySupportedService.S3;
    this._cliInputsFilePath = path.resolve(path.join(projectBackendDirPath, AmplifyCategories.STORAGE, resourceName, 'cli-inputs.json'));
    this._resourceName = resourceName;
    this.buildFilePath = path.resolve(path.join(projectBackendDirPath, AmplifyCategories.STORAGE, resourceName, 'build'));
    if ( userInput ){
        this._inputPayload = userInput;
    } else {
        // Read cliInputs file if exists
        try {
          this._inputPayload = this.getCliInputPayload();
        } catch (e) {
          throw new Error('migrate project with command : amplify migrate <to be decided>');
        }
    }

    // validate cli-inputs.json
    const schemaValidator = new CLIInputSchemaValidator(this._service, this._category, "S3UserInputs" );
    schemaValidator.validateInput(JSON.stringify(this._inputPayload!));
  }

  public getUserInput(){
     // Read Cli Inputs file if exists
     if ( this._inputPayload ){
        return this._inputPayload;
     } else {
        try {
            this._inputPayload = this.getCliInputPayload();
          } catch (e) {
            throw new Error('migrate project with command : amplify migrate <to be decided>');
          }
     }
      return this._inputPayload;
  }

  public setPoolGroupList( poolGroupList : Array<string>){
    if(this._inputPayload) {
      this._inputPayload.groupList = poolGroupList;
    } else {
      throw Error("ERROR: Pool Group is updated in Add Storage ");
    }
  }

  public async isCLIInputsValid(cliInputs?: S3UserInputs) {
    if(!cliInputs) {
      cliInputs = this.getCliInputPayload();
    }
    const schemaValidator = new CLIInputSchemaValidator(this._service, this._category, "S3UserInputs" );
    console.log("SACPCDEBUG: Validating CLI-Inputs: ", JSON.stringify(cliInputs, null, 2));
    return await schemaValidator.validateInput(JSON.stringify(cliInputs));
  }

  public static getPermissionTypeFromCfnType( s3CFNPermissionType : S3CFNPermissionType ) : S3PermissionType {
    switch( s3CFNPermissionType ){
        case S3CFNPermissionType.CREATE:
            return S3PermissionType.CREATE;
        case S3CFNPermissionType.READ:
            return S3PermissionType.READ;
        case S3CFNPermissionType.DELETE:
            return S3PermissionType.DELETE;
        case S3CFNPermissionType.LIST:
            return S3PermissionType.LIST;
        default:
            throw new Error(`Unknown CFN Type: ${s3CFNPermissionType}`);
    }
  }

//S3CFNPermissionType
  public static getCfnTypeFromPermissionType( s3PermissionType : S3PermissionType ) : S3CFNPermissionType {
    switch( s3PermissionType ){
        case S3PermissionType.CREATE:
            return S3CFNPermissionType.CREATE;
        case S3PermissionType.READ:
            return S3CFNPermissionType.READ;
        case S3PermissionType.DELETE:
            return  S3CFNPermissionType.DELETE;
        case S3PermissionType.LIST:
            return S3CFNPermissionType.LIST;
        default:
            throw new Error(`Unknown Permission Type: ${s3PermissionType}`);
    }
  }

  public static getInputPermissionsFromCfnPermissions( selectedGuestPermissions:S3CFNPermissionType[]| undefined ){
      if (selectedGuestPermissions){
          return selectedGuestPermissions.map( S3InputState.getPermissionTypeFromCfnType );
      } else {
          return []
      }
  }

  public static getCfnPermissionsFromInputPermissions( selectedPermissions:S3PermissionType[]| undefined ){
    if (selectedPermissions){
        return selectedPermissions.map( S3InputState.getCfnTypeFromPermissionType );
    } else {
        return []
    }
  }

  public static getPolicyMapFromCfnPolicyMap( groupCFNPolicyMap : GroupCFNAccessType ){
    if (groupCFNPolicyMap){
        let result : GroupAccessType = {} ;
        for ( const groupName of Object.keys( groupCFNPolicyMap )) {
            result[groupName] = this.getInputPermissionsFromCfnPermissions( groupCFNPolicyMap[groupName] )
        }
        return result;
    } else {
        return undefined;
    }
  }

  public static cliWalkThroughToCliInputParams( options: S3CLIWalkthroughParams ) : S3InputStateOptions {
    const inputProps: S3InputStateOptions = {
        resourceName : options.resourceName,
        inputPayload : {
            resourceName : options.resourceName,
            bucketName : options.bucketName,
            storageAccess : options.storageAccess,
            guestAccess: S3InputState.getInputPermissionsFromCfnPermissions(options.selectedGuestPermissions),
            authAccess : S3InputState.getInputPermissionsFromCfnPermissions( options.selectedAuthenticatedPermissions ),
            triggerFunction: (options.triggerFunction && (options.triggerFunction !== "NONE"))? options.triggerFunction:undefined,
            policyUUID : options.policyUUID,
            groupList : Object.keys(options.groupPolicyMap),
            groupAccess : S3InputState.getPolicyMapFromCfnPolicyMap( options.groupPolicyMap )
        },
        metadata : {
          dependsOn : options.dependsOn
        }
    }
    return inputProps;
  }

  public getCliInputParams():AmplifyS3ResourceInputParameters{
     const userInput : S3UserInputs = this.getUserInput();
     const cliInputParams: AmplifyS3ResourceInputParameters = {
        bucketName : userInput.bucketName,
        triggerFunction: ( userInput.triggerFunction && userInput.triggerFunction !== "NONE")? userInput.triggerFunction:undefined,
        selectedGuestPermissions: S3InputState.getCfnPermissionsFromInputPermissions(userInput.guestAccess),
        selectedAuthenticatedPermissions: S3InputState.getCfnPermissionsFromInputPermissions(userInput.authAccess),
     }
     return cliInputParams;
  }

updateInputPayload( props: S3InputStateOptions ){
    // Overwrite
    this._inputPayload = props.inputPayload;

    // validate cli-inputs.json
    const schemaValidator = new CLIInputSchemaValidator(this._service, this._category, "S3UserInputs" );
    schemaValidator.validateInput(JSON.stringify(this._inputPayload!));
}

public static getInstance(props: S3InputStateOptions): S3InputState {
    if (!S3InputState.s3InputState) {
      S3InputState.s3InputState = new S3InputState(props.resourceName, props.inputPayload);
    }
    //update flow
    if (props.inputPayload) {
      S3InputState.s3InputState.updateInputPayload(props);
    }
    return S3InputState.s3InputState;
}

public getCliInputPayload(): S3UserInputs {
    let cliInputs: S3UserInputs;
    // Read cliInputs file if exists
    try {
        cliInputs = JSON.parse(fs.readFileSync(this._cliInputsFilePath, 'utf8'));
    } catch (e) {
        throw new Error('migrate project with command : amplify migrate <to be decided>');
    }
    return cliInputs;
}

public getCliMetadata() : S3FeatureMetadata|undefined {
  return undefined;
}

public saveCliInputPayload(cliInputs: S3UserInputs): void {
  this.isCLIInputsValid(cliInputs);
  this._inputPayload = cliInputs;

  fs.ensureDirSync(path.join(pathManager.getBackendDirPath(), this._category, this._resourceName));

  try {
    JSONUtilities.writeJson(this._cliInputsFilePath, cliInputs);
  } catch (e) {
    throw e;
  }
}

}